/* tslint:disable */
/* eslint-disable */
/**
 * pantryplus-api
 * This is the API layer for the PantryPlus mobile app
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * A category is a grouping of related items within a list.
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * UUID representation of the category\'s ID
     * @type {string}
     * @memberof Category
     */
    'id': string;
    /**
     * The name of the category
     * @type {string}
     * @memberof Category
     */
    'name': string;
    /**
     * The list to which the category belongs
     * @type {string}
     * @memberof Category
     */
    'listId': string;
    /**
     * The ordinal of the category
     * @type {number}
     * @memberof Category
     */
    'ordinal': number;
}
/**
 * A Group is a user generated collection of Shoppers.
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {Shopper}
     * @memberof Group
     */
    'owner': Shopper;
    /**
     * The name of the group
     * @type {string}
     * @memberof Group
     */
    'name': string;
    /**
     * UUID representation of the group\'s ID
     * @type {string}
     * @memberof Group
     */
    'id': string;
}
/**
 * An Item is something a user may purchase.
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * UUID representation of the item\'s ID
     * @type {string}
     * @memberof Item
     */
    'id': string;
    /**
     * The name of the item
     * @type {string}
     * @memberof Item
     */
    'name': string;
    /**
     * The universal product code of the item
     * @type {string}
     * @memberof Item
     */
    'upc'?: string;
}
/**
 * A List is a grouping of items.
 * @export
 * @interface List
 */
export interface List {
    /**
     * UUID representation of the list\'s ID
     * @type {string}
     * @memberof List
     */
    'id': string;
    /**
     * The name of the list
     * @type {string}
     * @memberof List
     */
    'name': string;
    /**
     * The shopper that originally created the list
     * @type {string}
     * @memberof List
     */
    'ownerId': string;
    /**
     * The group of users with whom this list is shared
     * @type {string}
     * @memberof List
     */
    'groupId'?: string;
    /**
     * The ordinal of the list
     * @type {number}
     * @memberof List
     */
    'ordinal': number;
}
/**
 * The location of a store at which items may be purchased. GEO_LOCATION is a POINT(longitude, latitude) example: POINT(-71.44508663777015, 42.71299408793443)
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * UUID representation of the location\'s ID
     * @type {string}
     * @memberof Location
     */
    'id': string;
    /**
     * The name of the location
     * @type {string}
     * @memberof Location
     */
    'name': string;
    /**
     * The latitude of the user\'s current location
     * @type {number}
     * @memberof Location
     */
    'latitude': number;
    /**
     * The longitude of the user\'s current location
     * @type {number}
     * @memberof Location
     */
    'longitude': number;
}
/**
 * 
 * @export
 * @interface LocationArea
 */
export interface LocationArea {
    /**
     * The latitude of the user\'s current location
     * @type {number}
     * @memberof LocationArea
     */
    'latitude': number;
    /**
     * The longitude of the user\'s current location
     * @type {number}
     * @memberof LocationArea
     */
    'longitude': number;
    /**
     * The radius of the search
     * @type {number}
     * @memberof LocationArea
     */
    'radius': number;
}
/**
 * 
 * @export
 * @interface NearbyLocation
 */
export interface NearbyLocation {
    /**
     * UUID representation of the location\'s ID
     * @type {string}
     * @memberof NearbyLocation
     */
    'id': string;
    /**
     * The name of the location
     * @type {string}
     * @memberof NearbyLocation
     */
    'name': string;
    /**
     * The latitude of the user\'s current location
     * @type {number}
     * @memberof NearbyLocation
     */
    'latitude': number;
    /**
     * The longitude of the user\'s current location
     * @type {number}
     * @memberof NearbyLocation
     */
    'longitude': number;
    /**
     * The distance from the user\'s current location to the location
     * @type {number}
     * @memberof NearbyLocation
     */
    'distance': number;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickCategoryNameOrOrdinal
 */
export interface PickCategoryNameOrOrdinal {
    /**
     * The name of the category
     * @type {string}
     * @memberof PickCategoryNameOrOrdinal
     */
    'name': string;
    /**
     * The ordinal of the category
     * @type {number}
     * @memberof PickCategoryNameOrOrdinal
     */
    'ordinal': number;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickGroupIdOrNameOrOwner
 */
export interface PickGroupIdOrNameOrOwner {
    /**
     * UUID representation of the group\'s ID
     * @type {string}
     * @memberof PickGroupIdOrNameOrOwner
     */
    'id': string;
    /**
     * The name of the group
     * @type {string}
     * @memberof PickGroupIdOrNameOrOwner
     */
    'name': string;
    /**
     * 
     * @type {Shopper}
     * @memberof PickGroupIdOrNameOrOwner
     */
    'owner': Shopper;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickGroupName
 */
export interface PickGroupName {
    /**
     * The name of the group
     * @type {string}
     * @memberof PickGroupName
     */
    'name': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickGroupNameOrId
 */
export interface PickGroupNameOrId {
    /**
     * UUID representation of the group\'s ID
     * @type {string}
     * @memberof PickGroupNameOrId
     */
    'id': string;
    /**
     * The name of the group
     * @type {string}
     * @memberof PickGroupNameOrId
     */
    'name': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickItemNameOrUpc
 */
export interface PickItemNameOrUpc {
    /**
     * The name of the item
     * @type {string}
     * @memberof PickItemNameOrUpc
     */
    'name': string;
    /**
     * The universal product code of the item
     * @type {string}
     * @memberof PickItemNameOrUpc
     */
    'upc'?: string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickListNameOrGroupIdOrOrdinal
 */
export interface PickListNameOrGroupIdOrOrdinal {
    /**
     * The name of the list
     * @type {string}
     * @memberof PickListNameOrGroupIdOrOrdinal
     */
    'name': string;
    /**
     * The group of users with whom this list is shared
     * @type {string}
     * @memberof PickListNameOrGroupIdOrOrdinal
     */
    'groupId'?: string;
    /**
     * The ordinal of the list
     * @type {number}
     * @memberof PickListNameOrGroupIdOrOrdinal
     */
    'ordinal': number;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickLocationId
 */
export interface PickLocationId {
    /**
     * UUID representation of the location\'s ID
     * @type {string}
     * @memberof PickLocationId
     */
    'id': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickLocationName
 */
export interface PickLocationName {
    /**
     * The name of the location
     * @type {string}
     * @memberof PickLocationName
     */
    'name': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickShopperEmail
 */
export interface PickShopperEmail {
    /**
     * The email of the shopper
     * @type {string}
     * @memberof PickShopperEmail
     */
    'email': string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickShopperId
 */
export interface PickShopperId {
    /**
     * UUID representation of the shopper\'s ID
     * @type {string}
     * @memberof PickShopperId
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface RecentLocation
 */
export interface RecentLocation {
    /**
     * UUID representation of the location\'s ID
     * @type {string}
     * @memberof RecentLocation
     */
    'id': string;
    /**
     * The name of the location
     * @type {string}
     * @memberof RecentLocation
     */
    'name': string;
    /**
     * The latitude of the user\'s current location
     * @type {number}
     * @memberof RecentLocation
     */
    'latitude': number;
    /**
     * The longitude of the user\'s current location
     * @type {number}
     * @memberof RecentLocation
     */
    'longitude': number;
    /**
     * The date of the purchase
     * @type {string}
     * @memberof RecentLocation
     */
    'lastPurchaseDate': string;
}
/**
 * A Shopper is a user who has an account with us.
 * @export
 * @interface Shopper
 */
export interface Shopper {
    /**
     * UUID representation of the shopper\'s ID
     * @type {string}
     * @memberof Shopper
     */
    'id': string;
    /**
     * The nickname of the shopper
     * @type {string}
     * @memberof Shopper
     */
    'nickname': string;
    /**
     * The email of the shopper
     * @type {string}
     * @memberof Shopper
     */
    'email': string;
}
/**
 * an object containing the date of purchase
 * @export
 * @interface UnpurchaseItemRequest
 */
export interface UnpurchaseItemRequest {
    /**
     * 
     * @type {string}
     * @memberof UnpurchaseItemRequest
     */
    'purchaseDate': string;
}

/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Associates an item with a category
         * @param {string} xAuthUser the email address of the user
         * @param {string} categoryId the ID of the category
         * @param {string} itemId the ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemToCategory: async (xAuthUser: string, categoryId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('addItemToCategory', 'xAuthUser', xAuthUser)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('addItemToCategory', 'categoryId', categoryId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('addItemToCategory', 'itemId', itemId)
            const localVarPath = `/categories/{categoryId}/items/{itemId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the items in a category
         * @param {string} xAuthUser the email address of the user
         * @param {string} categoryId the ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryItems: async (xAuthUser: string, categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('getCategoryItems', 'xAuthUser', xAuthUser)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCategoryItems', 'categoryId', categoryId)
            const localVarPath = `/categories/{categoryId}/items`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes an item from a category
         * @param {string} xAuthUser the email address of the user
         * @param {string} categoryId the ID of the category
         * @param {string} itemId the ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeItemFromCategory: async (xAuthUser: string, categoryId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('removeItemFromCategory', 'xAuthUser', xAuthUser)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('removeItemFromCategory', 'categoryId', categoryId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('removeItemFromCategory', 'itemId', itemId)
            const localVarPath = `/categories/{categoryId}/items/{itemId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a category
         * @param {string} xAuthUser the email of the user
         * @param {string} xAuthLocation the ID of the user\&#39;s nearest store location
         * @param {string} categoryId the ID of the category
         * @param {PickCategoryNameOrOrdinal} pickCategoryNameOrOrdinal an object containing the new name and ordinal of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (xAuthUser: string, xAuthLocation: string, categoryId: string, pickCategoryNameOrOrdinal: PickCategoryNameOrOrdinal, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('updateCategory', 'xAuthUser', xAuthUser)
            // verify required parameter 'xAuthLocation' is not null or undefined
            assertParamExists('updateCategory', 'xAuthLocation', xAuthLocation)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('updateCategory', 'categoryId', categoryId)
            // verify required parameter 'pickCategoryNameOrOrdinal' is not null or undefined
            assertParamExists('updateCategory', 'pickCategoryNameOrOrdinal', pickCategoryNameOrOrdinal)
            const localVarPath = `/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            if (xAuthLocation != null) {
                localVarHeaderParameter['X-Auth-Location'] = String(xAuthLocation);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickCategoryNameOrOrdinal, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Associates an item with a category
         * @param {string} xAuthUser the email address of the user
         * @param {string} categoryId the ID of the category
         * @param {string} itemId the ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addItemToCategory(xAuthUser: string, categoryId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addItemToCategory(xAuthUser, categoryId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.addItemToCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets the items in a category
         * @param {string} xAuthUser the email address of the user
         * @param {string} categoryId the ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryItems(xAuthUser: string, categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Item>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryItems(xAuthUser, categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.getCategoryItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Removes an item from a category
         * @param {string} xAuthUser the email address of the user
         * @param {string} categoryId the ID of the category
         * @param {string} itemId the ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeItemFromCategory(xAuthUser: string, categoryId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeItemFromCategory(xAuthUser, categoryId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.removeItemFromCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a category
         * @param {string} xAuthUser the email of the user
         * @param {string} xAuthLocation the ID of the user\&#39;s nearest store location
         * @param {string} categoryId the ID of the category
         * @param {PickCategoryNameOrOrdinal} pickCategoryNameOrOrdinal an object containing the new name and ordinal of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(xAuthUser: string, xAuthLocation: string, categoryId: string, pickCategoryNameOrOrdinal: PickCategoryNameOrOrdinal, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(xAuthUser, xAuthLocation, categoryId, pickCategoryNameOrOrdinal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoriesApi.updateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Associates an item with a category
         * @param {string} xAuthUser the email address of the user
         * @param {string} categoryId the ID of the category
         * @param {string} itemId the ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemToCategory(xAuthUser: string, categoryId: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addItemToCategory(xAuthUser, categoryId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the items in a category
         * @param {string} xAuthUser the email address of the user
         * @param {string} categoryId the ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryItems(xAuthUser: string, categoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Item>> {
            return localVarFp.getCategoryItems(xAuthUser, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes an item from a category
         * @param {string} xAuthUser the email address of the user
         * @param {string} categoryId the ID of the category
         * @param {string} itemId the ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeItemFromCategory(xAuthUser: string, categoryId: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeItemFromCategory(xAuthUser, categoryId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a category
         * @param {string} xAuthUser the email of the user
         * @param {string} xAuthLocation the ID of the user\&#39;s nearest store location
         * @param {string} categoryId the ID of the category
         * @param {PickCategoryNameOrOrdinal} pickCategoryNameOrOrdinal an object containing the new name and ordinal of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(xAuthUser: string, xAuthLocation: string, categoryId: string, pickCategoryNameOrOrdinal: PickCategoryNameOrOrdinal, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateCategory(xAuthUser, xAuthLocation, categoryId, pickCategoryNameOrOrdinal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * 
     * @summary Associates an item with a category
     * @param {string} xAuthUser the email address of the user
     * @param {string} categoryId the ID of the category
     * @param {string} itemId the ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public addItemToCategory(xAuthUser: string, categoryId: string, itemId: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).addItemToCategory(xAuthUser, categoryId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the items in a category
     * @param {string} xAuthUser the email address of the user
     * @param {string} categoryId the ID of the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategoryItems(xAuthUser: string, categoryId: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).getCategoryItems(xAuthUser, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes an item from a category
     * @param {string} xAuthUser the email address of the user
     * @param {string} categoryId the ID of the category
     * @param {string} itemId the ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public removeItemFromCategory(xAuthUser: string, categoryId: string, itemId: string, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).removeItemFromCategory(xAuthUser, categoryId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a category
     * @param {string} xAuthUser the email of the user
     * @param {string} xAuthLocation the ID of the user\&#39;s nearest store location
     * @param {string} categoryId the ID of the category
     * @param {PickCategoryNameOrOrdinal} pickCategoryNameOrOrdinal an object containing the new name and ordinal of the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public updateCategory(xAuthUser: string, xAuthLocation: string, categoryId: string, pickCategoryNameOrOrdinal: PickCategoryNameOrOrdinal, options?: RawAxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).updateCategory(xAuthUser, xAuthLocation, categoryId, pickCategoryNameOrOrdinal, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a shopper to a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {PickShopperId} pickShopperId an object containing the ID of the shopper to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addShopperToGroup: async (xAuthUser: string, groupId: string, pickShopperId: PickShopperId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('addShopperToGroup', 'xAuthUser', xAuthUser)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('addShopperToGroup', 'groupId', groupId)
            // verify required parameter 'pickShopperId' is not null or undefined
            assertParamExists('addShopperToGroup', 'pickShopperId', pickShopperId)
            const localVarPath = `/groups/{groupId}/shoppers`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickShopperId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new group of shoppers
         * @param {string} xAuthUser the email address of the user
         * @param {PickGroupNameOrId} pickGroupNameOrId an object containing the name and ID of the group to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (xAuthUser: string, pickGroupNameOrId: PickGroupNameOrId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('createGroup', 'xAuthUser', xAuthUser)
            // verify required parameter 'pickGroupNameOrId' is not null or undefined
            assertParamExists('createGroup', 'pickGroupNameOrId', pickGroupNameOrId)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickGroupNameOrId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an existing group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (xAuthUser: string, groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('deleteGroup', 'xAuthUser', xAuthUser)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an existing group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (xAuthUser: string, groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('getGroup', 'xAuthUser', xAuthUser)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all shoppers in an existing group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupShoppers: async (xAuthUser: string, groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('getGroupShoppers', 'xAuthUser', xAuthUser)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupShoppers', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/shoppers`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all invitees for a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitees: async (xAuthUser: string, groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('getInvitees', 'xAuthUser', xAuthUser)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getInvitees', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/invitees`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invites a shopper to join a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {PickShopperEmail} pickShopperEmail an object containing the email address of the shopper to be invited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteShopper: async (xAuthUser: string, groupId: string, pickShopperEmail: PickShopperEmail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('inviteShopper', 'xAuthUser', xAuthUser)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('inviteShopper', 'groupId', groupId)
            // verify required parameter 'pickShopperEmail' is not null or undefined
            assertParamExists('inviteShopper', 'pickShopperEmail', pickShopperEmail)
            const localVarPath = `/groups/{groupId}/invitees`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickShopperEmail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes a shopper from a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {string} shopperId the ID of the shopper to be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeShopperFromGroup: async (xAuthUser: string, groupId: string, shopperId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('removeShopperFromGroup', 'xAuthUser', xAuthUser)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('removeShopperFromGroup', 'groupId', groupId)
            // verify required parameter 'shopperId' is not null or undefined
            assertParamExists('removeShopperFromGroup', 'shopperId', shopperId)
            const localVarPath = `/groups/{groupId}/shoppers/{shopperId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"shopperId"}}`, encodeURIComponent(String(shopperId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uninvites a shopper from a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {PickShopperEmail} pickShopperEmail an object containing the email address of the shopper to be uninvited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninviteShopper: async (xAuthUser: string, groupId: string, pickShopperEmail: PickShopperEmail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('uninviteShopper', 'xAuthUser', xAuthUser)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('uninviteShopper', 'groupId', groupId)
            // verify required parameter 'pickShopperEmail' is not null or undefined
            assertParamExists('uninviteShopper', 'pickShopperEmail', pickShopperEmail)
            const localVarPath = `/groups/{groupId}/invitees`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickShopperEmail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing group name
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {PickGroupName} pickGroupName an object containing the new name of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupName: async (xAuthUser: string, groupId: string, pickGroupName: PickGroupName, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('updateGroupName', 'xAuthUser', xAuthUser)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroupName', 'groupId', groupId)
            // verify required parameter 'pickGroupName' is not null or undefined
            assertParamExists('updateGroupName', 'pickGroupName', pickGroupName)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickGroupName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds a shopper to a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {PickShopperId} pickShopperId an object containing the ID of the shopper to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addShopperToGroup(xAuthUser: string, groupId: string, pickShopperId: PickShopperId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addShopperToGroup(xAuthUser, groupId, pickShopperId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.addShopperToGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a new group of shoppers
         * @param {string} xAuthUser the email address of the user
         * @param {PickGroupNameOrId} pickGroupNameOrId an object containing the name and ID of the group to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(xAuthUser: string, pickGroupNameOrId: PickGroupNameOrId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(xAuthUser, pickGroupNameOrId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.createGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes an existing group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(xAuthUser: string, groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(xAuthUser, groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets an existing group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(xAuthUser: string, groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickGroupIdOrNameOrOwner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(xAuthUser, groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets all shoppers in an existing group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupShoppers(xAuthUser: string, groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Shopper>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupShoppers(xAuthUser, groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupShoppers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets all invitees for a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvitees(xAuthUser: string, groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PickShopperEmail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvitees(xAuthUser, groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getInvitees']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Invites a shopper to join a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {PickShopperEmail} pickShopperEmail an object containing the email address of the shopper to be invited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteShopper(xAuthUser: string, groupId: string, pickShopperEmail: PickShopperEmail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteShopper(xAuthUser, groupId, pickShopperEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.inviteShopper']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Removes a shopper from a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {string} shopperId the ID of the shopper to be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeShopperFromGroup(xAuthUser: string, groupId: string, shopperId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeShopperFromGroup(xAuthUser, groupId, shopperId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.removeShopperFromGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Uninvites a shopper from a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {PickShopperEmail} pickShopperEmail an object containing the email address of the shopper to be uninvited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninviteShopper(xAuthUser: string, groupId: string, pickShopperEmail: PickShopperEmail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninviteShopper(xAuthUser, groupId, pickShopperEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.uninviteShopper']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates an existing group name
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {PickGroupName} pickGroupName an object containing the new name of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupName(xAuthUser: string, groupId: string, pickGroupName: PickGroupName, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupName(xAuthUser, groupId, pickGroupName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.updateGroupName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds a shopper to a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {PickShopperId} pickShopperId an object containing the ID of the shopper to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addShopperToGroup(xAuthUser: string, groupId: string, pickShopperId: PickShopperId, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addShopperToGroup(xAuthUser, groupId, pickShopperId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new group of shoppers
         * @param {string} xAuthUser the email address of the user
         * @param {PickGroupNameOrId} pickGroupNameOrId an object containing the name and ID of the group to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(xAuthUser: string, pickGroupNameOrId: PickGroupNameOrId, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createGroup(xAuthUser, pickGroupNameOrId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an existing group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(xAuthUser: string, groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGroup(xAuthUser, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an existing group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(xAuthUser: string, groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<PickGroupIdOrNameOrOwner> {
            return localVarFp.getGroup(xAuthUser, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all shoppers in an existing group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupShoppers(xAuthUser: string, groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Shopper>> {
            return localVarFp.getGroupShoppers(xAuthUser, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all invitees for a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitees(xAuthUser: string, groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PickShopperEmail>> {
            return localVarFp.getInvitees(xAuthUser, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invites a shopper to join a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {PickShopperEmail} pickShopperEmail an object containing the email address of the shopper to be invited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteShopper(xAuthUser: string, groupId: string, pickShopperEmail: PickShopperEmail, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.inviteShopper(xAuthUser, groupId, pickShopperEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes a shopper from a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {string} shopperId the ID of the shopper to be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeShopperFromGroup(xAuthUser: string, groupId: string, shopperId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeShopperFromGroup(xAuthUser, groupId, shopperId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uninvites a shopper from a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {PickShopperEmail} pickShopperEmail an object containing the email address of the shopper to be uninvited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninviteShopper(xAuthUser: string, groupId: string, pickShopperEmail: PickShopperEmail, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uninviteShopper(xAuthUser, groupId, pickShopperEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an existing group name
         * @param {string} xAuthUser the email address of the user
         * @param {string} groupId the ID of the group to be updated
         * @param {PickGroupName} pickGroupName an object containing the new name of the group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupName(xAuthUser: string, groupId: string, pickGroupName: PickGroupName, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateGroupName(xAuthUser, groupId, pickGroupName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Adds a shopper to a group
     * @param {string} xAuthUser the email address of the user
     * @param {string} groupId the ID of the group to be updated
     * @param {PickShopperId} pickShopperId an object containing the ID of the shopper to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public addShopperToGroup(xAuthUser: string, groupId: string, pickShopperId: PickShopperId, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).addShopperToGroup(xAuthUser, groupId, pickShopperId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new group of shoppers
     * @param {string} xAuthUser the email address of the user
     * @param {PickGroupNameOrId} pickGroupNameOrId an object containing the name and ID of the group to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(xAuthUser: string, pickGroupNameOrId: PickGroupNameOrId, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroup(xAuthUser, pickGroupNameOrId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an existing group
     * @param {string} xAuthUser the email address of the user
     * @param {string} groupId the ID of the group to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroup(xAuthUser: string, groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroup(xAuthUser, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an existing group
     * @param {string} xAuthUser the email address of the user
     * @param {string} groupId the ID of the group to be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroup(xAuthUser: string, groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroup(xAuthUser, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all shoppers in an existing group
     * @param {string} xAuthUser the email address of the user
     * @param {string} groupId the ID of the group to be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupShoppers(xAuthUser: string, groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupShoppers(xAuthUser, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all invitees for a group
     * @param {string} xAuthUser the email address of the user
     * @param {string} groupId the ID of the group to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getInvitees(xAuthUser: string, groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getInvitees(xAuthUser, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invites a shopper to join a group
     * @param {string} xAuthUser the email address of the user
     * @param {string} groupId the ID of the group to be updated
     * @param {PickShopperEmail} pickShopperEmail an object containing the email address of the shopper to be invited
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public inviteShopper(xAuthUser: string, groupId: string, pickShopperEmail: PickShopperEmail, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).inviteShopper(xAuthUser, groupId, pickShopperEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes a shopper from a group
     * @param {string} xAuthUser the email address of the user
     * @param {string} groupId the ID of the group to be updated
     * @param {string} shopperId the ID of the shopper to be removed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public removeShopperFromGroup(xAuthUser: string, groupId: string, shopperId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).removeShopperFromGroup(xAuthUser, groupId, shopperId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uninvites a shopper from a group
     * @param {string} xAuthUser the email address of the user
     * @param {string} groupId the ID of the group to be updated
     * @param {PickShopperEmail} pickShopperEmail an object containing the email address of the shopper to be uninvited
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public uninviteShopper(xAuthUser: string, groupId: string, pickShopperEmail: PickShopperEmail, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).uninviteShopper(xAuthUser, groupId, pickShopperEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an existing group name
     * @param {string} xAuthUser the email address of the user
     * @param {string} groupId the ID of the group to be updated
     * @param {PickGroupName} pickGroupName an object containing the new name of the group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupName(xAuthUser: string, groupId: string, pickGroupName: PickGroupName, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroupName(xAuthUser, groupId, pickGroupName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an item
         * @param {string} xAuthUser 
         * @param {Item} item an object containing the ID, name, and UPC of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem: async (xAuthUser: string, item: Item, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('createItem', 'xAuthUser', xAuthUser)
            // verify required parameter 'item' is not null or undefined
            assertParamExists('createItem', 'item', item)
            const localVarPath = `/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(item, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an item
         * @param {string} xAuthUser 
         * @param {string} itemId the ID of the item
         * @param {PickItemNameOrUpc} pickItemNameOrUpc an object containing the new name and UPC of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem: async (xAuthUser: string, itemId: string, pickItemNameOrUpc: PickItemNameOrUpc, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('updateItem', 'xAuthUser', xAuthUser)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('updateItem', 'itemId', itemId)
            // verify required parameter 'pickItemNameOrUpc' is not null or undefined
            assertParamExists('updateItem', 'pickItemNameOrUpc', pickItemNameOrUpc)
            const localVarPath = `/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickItemNameOrUpc, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates an item
         * @param {string} xAuthUser 
         * @param {Item} item an object containing the ID, name, and UPC of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItem(xAuthUser: string, item: Item, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItem(xAuthUser, item, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.createItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates an item
         * @param {string} xAuthUser 
         * @param {string} itemId the ID of the item
         * @param {PickItemNameOrUpc} pickItemNameOrUpc an object containing the new name and UPC of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItem(xAuthUser: string, itemId: string, pickItemNameOrUpc: PickItemNameOrUpc, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItem(xAuthUser, itemId, pickItemNameOrUpc, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.updateItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates an item
         * @param {string} xAuthUser 
         * @param {Item} item an object containing the ID, name, and UPC of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(xAuthUser: string, item: Item, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createItem(xAuthUser, item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an item
         * @param {string} xAuthUser 
         * @param {string} itemId the ID of the item
         * @param {PickItemNameOrUpc} pickItemNameOrUpc an object containing the new name and UPC of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(xAuthUser: string, itemId: string, pickItemNameOrUpc: PickItemNameOrUpc, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateItem(xAuthUser, itemId, pickItemNameOrUpc, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * 
     * @summary Creates an item
     * @param {string} xAuthUser 
     * @param {Item} item an object containing the ID, name, and UPC of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItem(xAuthUser: string, item: Item, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItem(xAuthUser, item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an item
     * @param {string} xAuthUser 
     * @param {string} itemId the ID of the item
     * @param {PickItemNameOrUpc} pickItemNameOrUpc an object containing the new name and UPC of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateItem(xAuthUser: string, itemId: string, pickItemNameOrUpc: PickItemNameOrUpc, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateItem(xAuthUser, itemId, pickItemNameOrUpc, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ListsApi - axios parameter creator
 * @export
 */
export const ListsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Associates an item with a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {string} itemId the ID of the item to associate with the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItem: async (xAuthUser: string, listId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('addItem', 'xAuthUser', xAuthUser)
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('addItem', 'listId', listId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('addItem', 'itemId', itemId)
            const localVarPath = `/lists/{listId}/items/{itemId}`
                .replace(`{${"listId"}}`, encodeURIComponent(String(listId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a category to a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} xAuthLocation the ID of the user\&#39;s nearest store location
         * @param {string} listId the ID of the list
         * @param {Category} category the category to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory: async (xAuthUser: string, xAuthLocation: string, listId: string, category: Category, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('createCategory', 'xAuthUser', xAuthUser)
            // verify required parameter 'xAuthLocation' is not null or undefined
            assertParamExists('createCategory', 'xAuthLocation', xAuthLocation)
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('createCategory', 'listId', listId)
            // verify required parameter 'category' is not null or undefined
            assertParamExists('createCategory', 'category', category)
            const localVarPath = `/lists/{listId}/categories`
                .replace(`{${"listId"}}`, encodeURIComponent(String(listId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            if (xAuthLocation != null) {
                localVarHeaderParameter['X-Auth-Location'] = String(xAuthLocation);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new list of items
         * @param {string} xAuthUser the email address of the user
         * @param {List} list the list to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createList: async (xAuthUser: string, list: List, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('createList', 'xAuthUser', xAuthUser)
            // verify required parameter 'list' is not null or undefined
            assertParamExists('createList', 'list', list)
            const localVarPath = `/lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(list, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a list of items
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteList: async (xAuthUser: string, listId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('deleteList', 'xAuthUser', xAuthUser)
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('deleteList', 'listId', listId)
            const localVarPath = `/lists/{listId}`
                .replace(`{${"listId"}}`, encodeURIComponent(String(listId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the categories for a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} xAuthLocation the ID of the location
         * @param {string} listId the ID of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (xAuthUser: string, xAuthLocation: string, listId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('getCategories', 'xAuthUser', xAuthUser)
            // verify required parameter 'xAuthLocation' is not null or undefined
            assertParamExists('getCategories', 'xAuthLocation', xAuthLocation)
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getCategories', 'listId', listId)
            const localVarPath = `/lists/{listId}/categories`
                .replace(`{${"listId"}}`, encodeURIComponent(String(listId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            if (xAuthLocation != null) {
                localVarHeaderParameter['X-Auth-Location'] = String(xAuthLocation);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves the uncategorized items for a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListItems: async (xAuthUser: string, listId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('getListItems', 'xAuthUser', xAuthUser)
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('getListItems', 'listId', listId)
            const localVarPath = `/lists/{listId}/items`
                .replace(`{${"listId"}}`, encodeURIComponent(String(listId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Purchases an item on a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} xAuthLocation the ID of the location
         * @param {string} listId the ID of the list
         * @param {string} itemId the ID of the item to purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseItem: async (xAuthUser: string, xAuthLocation: string, listId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('purchaseItem', 'xAuthUser', xAuthUser)
            // verify required parameter 'xAuthLocation' is not null or undefined
            assertParamExists('purchaseItem', 'xAuthLocation', xAuthLocation)
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('purchaseItem', 'listId', listId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('purchaseItem', 'itemId', itemId)
            const localVarPath = `/lists/{listId}/items/{itemId}/purchase`
                .replace(`{${"listId"}}`, encodeURIComponent(String(listId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            if (xAuthLocation != null) {
                localVarHeaderParameter['X-Auth-Location'] = String(xAuthLocation);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes a category from a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {string} categoryId the ID of the category to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCategory: async (xAuthUser: string, listId: string, categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('removeCategory', 'xAuthUser', xAuthUser)
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('removeCategory', 'listId', listId)
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('removeCategory', 'categoryId', categoryId)
            const localVarPath = `/lists/{listId}/categories/{categoryId}`
                .replace(`{${"listId"}}`, encodeURIComponent(String(listId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes an item from a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {string} itemId the ID of the item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeItem: async (xAuthUser: string, listId: string, itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('removeItem', 'xAuthUser', xAuthUser)
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('removeItem', 'listId', listId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('removeItem', 'itemId', itemId)
            const localVarPath = `/lists/{listId}/items/{itemId}`
                .replace(`{${"listId"}}`, encodeURIComponent(String(listId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes the purchase of an item from purchase history
         * @param {string} xAuthUser the email address of the user
         * @param {string} xAuthLocation the ID of the location
         * @param {string} listId the ID of the list
         * @param {string} itemId the ID of the item to remove
         * @param {UnpurchaseItemRequest} unpurchaseItemRequest an object containing the date of purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpurchaseItem: async (xAuthUser: string, xAuthLocation: string, listId: string, itemId: string, unpurchaseItemRequest: UnpurchaseItemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('unpurchaseItem', 'xAuthUser', xAuthUser)
            // verify required parameter 'xAuthLocation' is not null or undefined
            assertParamExists('unpurchaseItem', 'xAuthLocation', xAuthLocation)
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('unpurchaseItem', 'listId', listId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('unpurchaseItem', 'itemId', itemId)
            // verify required parameter 'unpurchaseItemRequest' is not null or undefined
            assertParamExists('unpurchaseItem', 'unpurchaseItemRequest', unpurchaseItemRequest)
            const localVarPath = `/lists/{listId}/items/{itemId}/purchase`
                .replace(`{${"listId"}}`, encodeURIComponent(String(listId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            if (xAuthLocation != null) {
                localVarHeaderParameter['X-Auth-Location'] = String(xAuthLocation);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unpurchaseItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {PickListNameOrGroupIdOrOrdinal} pickListNameOrGroupIdOrOrdinal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateList: async (xAuthUser: string, listId: string, pickListNameOrGroupIdOrOrdinal: PickListNameOrGroupIdOrOrdinal, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('updateList', 'xAuthUser', xAuthUser)
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('updateList', 'listId', listId)
            // verify required parameter 'pickListNameOrGroupIdOrOrdinal' is not null or undefined
            assertParamExists('updateList', 'pickListNameOrGroupIdOrOrdinal', pickListNameOrGroupIdOrOrdinal)
            const localVarPath = `/lists/{listId}`
                .replace(`{${"listId"}}`, encodeURIComponent(String(listId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickListNameOrGroupIdOrOrdinal, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListsApi - functional programming interface
 * @export
 */
export const ListsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Associates an item with a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {string} itemId the ID of the item to associate with the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addItem(xAuthUser: string, listId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addItem(xAuthUser, listId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.addItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Adds a category to a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} xAuthLocation the ID of the user\&#39;s nearest store location
         * @param {string} listId the ID of the list
         * @param {Category} category the category to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCategory(xAuthUser: string, xAuthLocation: string, listId: string, category: Category, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCategory(xAuthUser, xAuthLocation, listId, category, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.createCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a new list of items
         * @param {string} xAuthUser the email address of the user
         * @param {List} list the list to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createList(xAuthUser: string, list: List, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createList(xAuthUser, list, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.createList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a list of items
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteList(xAuthUser: string, listId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteList(xAuthUser, listId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.deleteList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves the categories for a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} xAuthLocation the ID of the location
         * @param {string} listId the ID of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(xAuthUser: string, xAuthLocation: string, listId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(xAuthUser, xAuthLocation, listId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves the uncategorized items for a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListItems(xAuthUser: string, listId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Item>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListItems(xAuthUser, listId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getListItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Purchases an item on a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} xAuthLocation the ID of the location
         * @param {string} listId the ID of the list
         * @param {string} itemId the ID of the item to purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchaseItem(xAuthUser: string, xAuthLocation: string, listId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseItem(xAuthUser, xAuthLocation, listId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.purchaseItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Removes a category from a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {string} categoryId the ID of the category to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCategory(xAuthUser: string, listId: string, categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCategory(xAuthUser, listId, categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.removeCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Removes an item from a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {string} itemId the ID of the item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeItem(xAuthUser: string, listId: string, itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeItem(xAuthUser, listId, itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.removeItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Removes the purchase of an item from purchase history
         * @param {string} xAuthUser the email address of the user
         * @param {string} xAuthLocation the ID of the location
         * @param {string} listId the ID of the list
         * @param {string} itemId the ID of the item to remove
         * @param {UnpurchaseItemRequest} unpurchaseItemRequest an object containing the date of purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpurchaseItem(xAuthUser: string, xAuthLocation: string, listId: string, itemId: string, unpurchaseItemRequest: UnpurchaseItemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpurchaseItem(xAuthUser, xAuthLocation, listId, itemId, unpurchaseItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.unpurchaseItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {PickListNameOrGroupIdOrOrdinal} pickListNameOrGroupIdOrOrdinal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateList(xAuthUser: string, listId: string, pickListNameOrGroupIdOrOrdinal: PickListNameOrGroupIdOrOrdinal, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateList(xAuthUser, listId, pickListNameOrGroupIdOrOrdinal, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.updateList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ListsApi - factory interface
 * @export
 */
export const ListsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListsApiFp(configuration)
    return {
        /**
         * 
         * @summary Associates an item with a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {string} itemId the ID of the item to associate with the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItem(xAuthUser: string, listId: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addItem(xAuthUser, listId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a category to a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} xAuthLocation the ID of the user\&#39;s nearest store location
         * @param {string} listId the ID of the list
         * @param {Category} category the category to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(xAuthUser: string, xAuthLocation: string, listId: string, category: Category, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createCategory(xAuthUser, xAuthLocation, listId, category, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new list of items
         * @param {string} xAuthUser the email address of the user
         * @param {List} list the list to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createList(xAuthUser: string, list: List, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createList(xAuthUser, list, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a list of items
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteList(xAuthUser: string, listId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteList(xAuthUser, listId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the categories for a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} xAuthLocation the ID of the location
         * @param {string} listId the ID of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(xAuthUser: string, xAuthLocation: string, listId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Category>> {
            return localVarFp.getCategories(xAuthUser, xAuthLocation, listId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves the uncategorized items for a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListItems(xAuthUser: string, listId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Item>> {
            return localVarFp.getListItems(xAuthUser, listId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Purchases an item on a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} xAuthLocation the ID of the location
         * @param {string} listId the ID of the list
         * @param {string} itemId the ID of the item to purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchaseItem(xAuthUser: string, xAuthLocation: string, listId: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.purchaseItem(xAuthUser, xAuthLocation, listId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes a category from a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {string} categoryId the ID of the category to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCategory(xAuthUser: string, listId: string, categoryId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeCategory(xAuthUser, listId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes an item from a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {string} itemId the ID of the item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeItem(xAuthUser: string, listId: string, itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeItem(xAuthUser, listId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes the purchase of an item from purchase history
         * @param {string} xAuthUser the email address of the user
         * @param {string} xAuthLocation the ID of the location
         * @param {string} listId the ID of the list
         * @param {string} itemId the ID of the item to remove
         * @param {UnpurchaseItemRequest} unpurchaseItemRequest an object containing the date of purchase
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpurchaseItem(xAuthUser: string, xAuthLocation: string, listId: string, itemId: string, unpurchaseItemRequest: UnpurchaseItemRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unpurchaseItem(xAuthUser, xAuthLocation, listId, itemId, unpurchaseItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a list
         * @param {string} xAuthUser the email address of the user
         * @param {string} listId the ID of the list
         * @param {PickListNameOrGroupIdOrOrdinal} pickListNameOrGroupIdOrOrdinal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateList(xAuthUser: string, listId: string, pickListNameOrGroupIdOrOrdinal: PickListNameOrGroupIdOrOrdinal, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateList(xAuthUser, listId, pickListNameOrGroupIdOrOrdinal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ListsApi - object-oriented interface
 * @export
 * @class ListsApi
 * @extends {BaseAPI}
 */
export class ListsApi extends BaseAPI {
    /**
     * 
     * @summary Associates an item with a list
     * @param {string} xAuthUser the email address of the user
     * @param {string} listId the ID of the list
     * @param {string} itemId the ID of the item to associate with the list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public addItem(xAuthUser: string, listId: string, itemId: string, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).addItem(xAuthUser, listId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a category to a list
     * @param {string} xAuthUser the email address of the user
     * @param {string} xAuthLocation the ID of the user\&#39;s nearest store location
     * @param {string} listId the ID of the list
     * @param {Category} category the category to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public createCategory(xAuthUser: string, xAuthLocation: string, listId: string, category: Category, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).createCategory(xAuthUser, xAuthLocation, listId, category, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new list of items
     * @param {string} xAuthUser the email address of the user
     * @param {List} list the list to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public createList(xAuthUser: string, list: List, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).createList(xAuthUser, list, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a list of items
     * @param {string} xAuthUser the email address of the user
     * @param {string} listId the ID of the list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public deleteList(xAuthUser: string, listId: string, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).deleteList(xAuthUser, listId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the categories for a list
     * @param {string} xAuthUser the email address of the user
     * @param {string} xAuthLocation the ID of the location
     * @param {string} listId the ID of the list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public getCategories(xAuthUser: string, xAuthLocation: string, listId: string, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getCategories(xAuthUser, xAuthLocation, listId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves the uncategorized items for a list
     * @param {string} xAuthUser the email address of the user
     * @param {string} listId the ID of the list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public getListItems(xAuthUser: string, listId: string, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getListItems(xAuthUser, listId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Purchases an item on a list
     * @param {string} xAuthUser the email address of the user
     * @param {string} xAuthLocation the ID of the location
     * @param {string} listId the ID of the list
     * @param {string} itemId the ID of the item to purchase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public purchaseItem(xAuthUser: string, xAuthLocation: string, listId: string, itemId: string, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).purchaseItem(xAuthUser, xAuthLocation, listId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes a category from a list
     * @param {string} xAuthUser the email address of the user
     * @param {string} listId the ID of the list
     * @param {string} categoryId the ID of the category to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public removeCategory(xAuthUser: string, listId: string, categoryId: string, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).removeCategory(xAuthUser, listId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes an item from a list
     * @param {string} xAuthUser the email address of the user
     * @param {string} listId the ID of the list
     * @param {string} itemId the ID of the item to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public removeItem(xAuthUser: string, listId: string, itemId: string, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).removeItem(xAuthUser, listId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes the purchase of an item from purchase history
     * @param {string} xAuthUser the email address of the user
     * @param {string} xAuthLocation the ID of the location
     * @param {string} listId the ID of the list
     * @param {string} itemId the ID of the item to remove
     * @param {UnpurchaseItemRequest} unpurchaseItemRequest an object containing the date of purchase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public unpurchaseItem(xAuthUser: string, xAuthLocation: string, listId: string, itemId: string, unpurchaseItemRequest: UnpurchaseItemRequest, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).unpurchaseItem(xAuthUser, xAuthLocation, listId, itemId, unpurchaseItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a list
     * @param {string} xAuthUser the email address of the user
     * @param {string} listId the ID of the list
     * @param {PickListNameOrGroupIdOrOrdinal} pickListNameOrGroupIdOrOrdinal 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public updateList(xAuthUser: string, listId: string, pickListNameOrGroupIdOrOrdinal: PickListNameOrGroupIdOrOrdinal, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).updateList(xAuthUser, listId, pickListNameOrGroupIdOrOrdinal, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationsApi - axios parameter creator
 * @export
 */
export const LocationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new location
         * @param {string} xAuthUser the email address of the user
         * @param {Location} location the location to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLocation: async (xAuthUser: string, location: Location, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('createLocation', 'xAuthUser', xAuthUser)
            // verify required parameter 'location' is not null or undefined
            assertParamExists('createLocation', 'location', location)
            const localVarPath = `/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(location, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all locations within a radius of the current location
         * @param {string} xAuthUser the email address of the user
         * @param {LocationArea} locationArea 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNearbyLocations: async (xAuthUser: string, locationArea: LocationArea, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('getNearbyLocations', 'xAuthUser', xAuthUser)
            // verify required parameter 'locationArea' is not null or undefined
            assertParamExists('getNearbyLocations', 'locationArea', locationArea)
            const localVarPath = `/locations/nearby`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(locationArea, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing location name
         * @param {string} xAuthUser the email address of the user
         * @param {string} locationId the ID of the location to be updated
         * @param {PickLocationName} pickLocationName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLocation: async (xAuthUser: string, locationId: string, pickLocationName: PickLocationName, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('updateLocation', 'xAuthUser', xAuthUser)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('updateLocation', 'locationId', locationId)
            // verify required parameter 'pickLocationName' is not null or undefined
            assertParamExists('updateLocation', 'pickLocationName', pickLocationName)
            const localVarPath = `/locations/{locationId}`
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pickLocationName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationsApi - functional programming interface
 * @export
 */
export const LocationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new location
         * @param {string} xAuthUser the email address of the user
         * @param {Location} location the location to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLocation(xAuthUser: string, location: Location, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickLocationId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLocation(xAuthUser, location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationsApi.createLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves all locations within a radius of the current location
         * @param {string} xAuthUser the email address of the user
         * @param {LocationArea} locationArea 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNearbyLocations(xAuthUser: string, locationArea: LocationArea, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NearbyLocation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNearbyLocations(xAuthUser, locationArea, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationsApi.getNearbyLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates an existing location name
         * @param {string} xAuthUser the email address of the user
         * @param {string} locationId the ID of the location to be updated
         * @param {PickLocationName} pickLocationName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLocation(xAuthUser: string, locationId: string, pickLocationName: PickLocationName, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLocation(xAuthUser, locationId, pickLocationName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationsApi.updateLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationsApi - factory interface
 * @export
 */
export const LocationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new location
         * @param {string} xAuthUser the email address of the user
         * @param {Location} location the location to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLocation(xAuthUser: string, location: Location, options?: RawAxiosRequestConfig): AxiosPromise<PickLocationId> {
            return localVarFp.createLocation(xAuthUser, location, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all locations within a radius of the current location
         * @param {string} xAuthUser the email address of the user
         * @param {LocationArea} locationArea 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNearbyLocations(xAuthUser: string, locationArea: LocationArea, options?: RawAxiosRequestConfig): AxiosPromise<Array<NearbyLocation>> {
            return localVarFp.getNearbyLocations(xAuthUser, locationArea, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an existing location name
         * @param {string} xAuthUser the email address of the user
         * @param {string} locationId the ID of the location to be updated
         * @param {PickLocationName} pickLocationName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLocation(xAuthUser: string, locationId: string, pickLocationName: PickLocationName, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateLocation(xAuthUser, locationId, pickLocationName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocationsApi - object-oriented interface
 * @export
 * @class LocationsApi
 * @extends {BaseAPI}
 */
export class LocationsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new location
     * @param {string} xAuthUser the email address of the user
     * @param {Location} location the location to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public createLocation(xAuthUser: string, location: Location, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).createLocation(xAuthUser, location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all locations within a radius of the current location
     * @param {string} xAuthUser the email address of the user
     * @param {LocationArea} locationArea 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public getNearbyLocations(xAuthUser: string, locationArea: LocationArea, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).getNearbyLocations(xAuthUser, locationArea, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an existing location name
     * @param {string} xAuthUser the email address of the user
     * @param {string} locationId the ID of the location to be updated
     * @param {PickLocationName} pickLocationName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationsApi
     */
    public updateLocation(xAuthUser: string, locationId: string, pickLocationName: PickLocationName, options?: RawAxiosRequestConfig) {
        return LocationsApiFp(this.configuration).updateLocation(xAuthUser, locationId, pickLocationName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ShoppersApi - axios parameter creator
 * @export
 */
export const ShoppersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accepts an invite to a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom the invite will be accepted
         * @param {string} inviteId the ID of the invite to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite: async (xAuthUser: string, shopperId: string, inviteId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('acceptInvite', 'xAuthUser', xAuthUser)
            // verify required parameter 'shopperId' is not null or undefined
            assertParamExists('acceptInvite', 'shopperId', shopperId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('acceptInvite', 'inviteId', inviteId)
            const localVarPath = `/shoppers/{shopperId}/invites/{inviteId}`
                .replace(`{${"shopperId"}}`, encodeURIComponent(String(shopperId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new shopper
         * @param {Shopper} shopper the shopper to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShopper: async (shopper: Shopper, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shopper' is not null or undefined
            assertParamExists('createShopper', 'shopper', shopper)
            const localVarPath = `/shoppers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopper, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Declines an invite to a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom the invite will be declined
         * @param {string} inviteId the ID of the invite to be declined
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineInvite: async (xAuthUser: string, shopperId: string, inviteId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('declineInvite', 'xAuthUser', xAuthUser)
            // verify required parameter 'shopperId' is not null or undefined
            assertParamExists('declineInvite', 'shopperId', shopperId)
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('declineInvite', 'inviteId', inviteId)
            const localVarPath = `/shoppers/{shopperId}/invites/{inviteId}`
                .replace(`{${"shopperId"}}`, encodeURIComponent(String(shopperId)))
                .replace(`{${"inviteId"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all of the groups associated with a Shopper
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom groups will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups: async (xAuthUser: string, shopperId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('getGroups', 'xAuthUser', xAuthUser)
            // verify required parameter 'shopperId' is not null or undefined
            assertParamExists('getGroups', 'shopperId', shopperId)
            const localVarPath = `/shoppers/{shopperId}/groups`
                .replace(`{${"shopperId"}}`, encodeURIComponent(String(shopperId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all groups that a Shopper has been invited to
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom invites will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvites: async (xAuthUser: string, shopperId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('getInvites', 'xAuthUser', xAuthUser)
            // verify required parameter 'shopperId' is not null or undefined
            assertParamExists('getInvites', 'shopperId', shopperId)
            const localVarPath = `/shoppers/{shopperId}/invites`
                .replace(`{${"shopperId"}}`, encodeURIComponent(String(shopperId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all lists associated with a Shopper
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom lists will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLists: async (xAuthUser: string, shopperId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('getLists', 'xAuthUser', xAuthUser)
            // verify required parameter 'shopperId' is not null or undefined
            assertParamExists('getLists', 'shopperId', shopperId)
            const localVarPath = `/shoppers/{shopperId}/lists`
                .replace(`{${"shopperId"}}`, encodeURIComponent(String(shopperId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all locations associated with a Shopper
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom locations will be returned
         * @param {number} lookBackDays the number of days to look back for purchases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocations: async (xAuthUser: string, shopperId: string, lookBackDays: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('getLocations', 'xAuthUser', xAuthUser)
            // verify required parameter 'shopperId' is not null or undefined
            assertParamExists('getLocations', 'shopperId', shopperId)
            // verify required parameter 'lookBackDays' is not null or undefined
            assertParamExists('getLocations', 'lookBackDays', lookBackDays)
            const localVarPath = `/shoppers/{shopperId}/locations`
                .replace(`{${"shopperId"}}`, encodeURIComponent(String(shopperId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lookBackDays !== undefined) {
                localVarQueryParameter['lookBackDays'] = lookBackDays;
            }


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all previously purchased items associated with a Shopper
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom items will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPurchasedItems: async (xAuthUser: string, shopperId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('getPurchasedItems', 'xAuthUser', xAuthUser)
            // verify required parameter 'shopperId' is not null or undefined
            assertParamExists('getPurchasedItems', 'shopperId', shopperId)
            const localVarPath = `/shoppers/{shopperId}/items`
                .replace(`{${"shopperId"}}`, encodeURIComponent(String(shopperId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a shopper by ID
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId The ID of the shopper to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShopper: async (xAuthUser: string, shopperId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('retrieveShopper', 'xAuthUser', xAuthUser)
            // verify required parameter 'shopperId' is not null or undefined
            assertParamExists('retrieveShopper', 'shopperId', shopperId)
            const localVarPath = `/shoppers/{shopperId}`
                .replace(`{${"shopperId"}}`, encodeURIComponent(String(shopperId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing shopper
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper to be updated
         * @param {Shopper} shopper the updated shopper properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShopper: async (xAuthUser: string, shopperId: string, shopper: Shopper, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthUser' is not null or undefined
            assertParamExists('updateShopper', 'xAuthUser', xAuthUser)
            // verify required parameter 'shopperId' is not null or undefined
            assertParamExists('updateShopper', 'shopperId', shopperId)
            // verify required parameter 'shopper' is not null or undefined
            assertParamExists('updateShopper', 'shopper', shopper)
            const localVarPath = `/shoppers/{shopperId}`
                .replace(`{${"shopperId"}}`, encodeURIComponent(String(shopperId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAuthUser != null) {
                localVarHeaderParameter['X-Auth-User'] = String(xAuthUser);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopper, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShoppersApi - functional programming interface
 * @export
 */
export const ShoppersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShoppersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accepts an invite to a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom the invite will be accepted
         * @param {string} inviteId the ID of the invite to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptInvite(xAuthUser: string, shopperId: string, inviteId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptInvite(xAuthUser, shopperId, inviteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShoppersApi.acceptInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a new shopper
         * @param {Shopper} shopper the shopper to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShopper(shopper: Shopper, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shopper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShopper(shopper, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShoppersApi.createShopper']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Declines an invite to a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom the invite will be declined
         * @param {string} inviteId the ID of the invite to be declined
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async declineInvite(xAuthUser: string, shopperId: string, inviteId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.declineInvite(xAuthUser, shopperId, inviteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShoppersApi.declineInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves all of the groups associated with a Shopper
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom groups will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroups(xAuthUser: string, shopperId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PickGroupIdOrNameOrOwner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroups(xAuthUser, shopperId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShoppersApi.getGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves all groups that a Shopper has been invited to
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom invites will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvites(xAuthUser: string, shopperId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvites(xAuthUser, shopperId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShoppersApi.getInvites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves all lists associated with a Shopper
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom lists will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLists(xAuthUser: string, shopperId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<List>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLists(xAuthUser, shopperId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShoppersApi.getLists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves all locations associated with a Shopper
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom locations will be returned
         * @param {number} lookBackDays the number of days to look back for purchases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocations(xAuthUser: string, shopperId: string, lookBackDays: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecentLocation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocations(xAuthUser, shopperId, lookBackDays, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShoppersApi.getLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves all previously purchased items associated with a Shopper
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom items will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPurchasedItems(xAuthUser: string, shopperId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Item>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPurchasedItems(xAuthUser, shopperId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShoppersApi.getPurchasedItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a shopper by ID
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId The ID of the shopper to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveShopper(xAuthUser: string, shopperId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shopper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveShopper(xAuthUser, shopperId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShoppersApi.retrieveShopper']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates an existing shopper
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper to be updated
         * @param {Shopper} shopper the updated shopper properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShopper(xAuthUser: string, shopperId: string, shopper: Shopper, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickShopperId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShopper(xAuthUser, shopperId, shopper, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShoppersApi.updateShopper']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShoppersApi - factory interface
 * @export
 */
export const ShoppersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShoppersApiFp(configuration)
    return {
        /**
         * 
         * @summary Accepts an invite to a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom the invite will be accepted
         * @param {string} inviteId the ID of the invite to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(xAuthUser: string, shopperId: string, inviteId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.acceptInvite(xAuthUser, shopperId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new shopper
         * @param {Shopper} shopper the shopper to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShopper(shopper: Shopper, options?: RawAxiosRequestConfig): AxiosPromise<Shopper> {
            return localVarFp.createShopper(shopper, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Declines an invite to a group
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom the invite will be declined
         * @param {string} inviteId the ID of the invite to be declined
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineInvite(xAuthUser: string, shopperId: string, inviteId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.declineInvite(xAuthUser, shopperId, inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all of the groups associated with a Shopper
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom groups will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(xAuthUser: string, shopperId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PickGroupIdOrNameOrOwner>> {
            return localVarFp.getGroups(xAuthUser, shopperId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all groups that a Shopper has been invited to
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom invites will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvites(xAuthUser: string, shopperId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Group>> {
            return localVarFp.getInvites(xAuthUser, shopperId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all lists associated with a Shopper
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom lists will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLists(xAuthUser: string, shopperId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<List>> {
            return localVarFp.getLists(xAuthUser, shopperId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all locations associated with a Shopper
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom locations will be returned
         * @param {number} lookBackDays the number of days to look back for purchases
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocations(xAuthUser: string, shopperId: string, lookBackDays: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<RecentLocation>> {
            return localVarFp.getLocations(xAuthUser, shopperId, lookBackDays, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all previously purchased items associated with a Shopper
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper for whom items will be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPurchasedItems(xAuthUser: string, shopperId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Item>> {
            return localVarFp.getPurchasedItems(xAuthUser, shopperId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a shopper by ID
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId The ID of the shopper to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShopper(xAuthUser: string, shopperId: string, options?: RawAxiosRequestConfig): AxiosPromise<Shopper> {
            return localVarFp.retrieveShopper(xAuthUser, shopperId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an existing shopper
         * @param {string} xAuthUser the email address of the user
         * @param {string} shopperId the ID of the shopper to be updated
         * @param {Shopper} shopper the updated shopper properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShopper(xAuthUser: string, shopperId: string, shopper: Shopper, options?: RawAxiosRequestConfig): AxiosPromise<PickShopperId> {
            return localVarFp.updateShopper(xAuthUser, shopperId, shopper, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShoppersApi - object-oriented interface
 * @export
 * @class ShoppersApi
 * @extends {BaseAPI}
 */
export class ShoppersApi extends BaseAPI {
    /**
     * 
     * @summary Accepts an invite to a group
     * @param {string} xAuthUser the email address of the user
     * @param {string} shopperId the ID of the shopper for whom the invite will be accepted
     * @param {string} inviteId the ID of the invite to be accepted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShoppersApi
     */
    public acceptInvite(xAuthUser: string, shopperId: string, inviteId: string, options?: RawAxiosRequestConfig) {
        return ShoppersApiFp(this.configuration).acceptInvite(xAuthUser, shopperId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new shopper
     * @param {Shopper} shopper the shopper to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShoppersApi
     */
    public createShopper(shopper: Shopper, options?: RawAxiosRequestConfig) {
        return ShoppersApiFp(this.configuration).createShopper(shopper, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Declines an invite to a group
     * @param {string} xAuthUser the email address of the user
     * @param {string} shopperId the ID of the shopper for whom the invite will be declined
     * @param {string} inviteId the ID of the invite to be declined
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShoppersApi
     */
    public declineInvite(xAuthUser: string, shopperId: string, inviteId: string, options?: RawAxiosRequestConfig) {
        return ShoppersApiFp(this.configuration).declineInvite(xAuthUser, shopperId, inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all of the groups associated with a Shopper
     * @param {string} xAuthUser the email address of the user
     * @param {string} shopperId the ID of the shopper for whom groups will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShoppersApi
     */
    public getGroups(xAuthUser: string, shopperId: string, options?: RawAxiosRequestConfig) {
        return ShoppersApiFp(this.configuration).getGroups(xAuthUser, shopperId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all groups that a Shopper has been invited to
     * @param {string} xAuthUser the email address of the user
     * @param {string} shopperId the ID of the shopper for whom invites will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShoppersApi
     */
    public getInvites(xAuthUser: string, shopperId: string, options?: RawAxiosRequestConfig) {
        return ShoppersApiFp(this.configuration).getInvites(xAuthUser, shopperId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all lists associated with a Shopper
     * @param {string} xAuthUser the email address of the user
     * @param {string} shopperId the ID of the shopper for whom lists will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShoppersApi
     */
    public getLists(xAuthUser: string, shopperId: string, options?: RawAxiosRequestConfig) {
        return ShoppersApiFp(this.configuration).getLists(xAuthUser, shopperId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all locations associated with a Shopper
     * @param {string} xAuthUser the email address of the user
     * @param {string} shopperId the ID of the shopper for whom locations will be returned
     * @param {number} lookBackDays the number of days to look back for purchases
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShoppersApi
     */
    public getLocations(xAuthUser: string, shopperId: string, lookBackDays: number, options?: RawAxiosRequestConfig) {
        return ShoppersApiFp(this.configuration).getLocations(xAuthUser, shopperId, lookBackDays, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all previously purchased items associated with a Shopper
     * @param {string} xAuthUser the email address of the user
     * @param {string} shopperId the ID of the shopper for whom items will be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShoppersApi
     */
    public getPurchasedItems(xAuthUser: string, shopperId: string, options?: RawAxiosRequestConfig) {
        return ShoppersApiFp(this.configuration).getPurchasedItems(xAuthUser, shopperId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a shopper by ID
     * @param {string} xAuthUser the email address of the user
     * @param {string} shopperId The ID of the shopper to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShoppersApi
     */
    public retrieveShopper(xAuthUser: string, shopperId: string, options?: RawAxiosRequestConfig) {
        return ShoppersApiFp(this.configuration).retrieveShopper(xAuthUser, shopperId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an existing shopper
     * @param {string} xAuthUser the email address of the user
     * @param {string} shopperId the ID of the shopper to be updated
     * @param {Shopper} shopper the updated shopper properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShoppersApi
     */
    public updateShopper(xAuthUser: string, shopperId: string, shopper: Shopper, options?: RawAxiosRequestConfig) {
        return ShoppersApiFp(this.configuration).updateShopper(xAuthUser, shopperId, shopper, options).then((request) => request(this.axios, this.basePath));
    }
}



